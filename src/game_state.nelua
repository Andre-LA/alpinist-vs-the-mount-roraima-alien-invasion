require 'nene'
require 'rotor-quick'

local Vec2, Rect = Nene.Math.Vec2, Nene.Math.Rect

global Game = @record{}
global Game.Systems = @record{}
global Game.Components = @record{}
global Game.Entities = @record{}

local RQ_Comps, RQ_Sys = RotorQuick.Components, RotorQuick.Systems
local GM_Sys, GM_Comps, GM_Ents = Game.Systems, Game.Components, Game.Entities

global Game.IntersectableMasks = @enum{
  Alpinist         = 1 << 0,
  Enemy            = 1 << 1,
  SurfaceTile      = 1 << 2,
  ProjAlpinist     = 1 << 3,
  ProjEnemy        = 1 << 4,
  NonIntersectable = 1 << 5,
}

global Game.SpriteLayer = @enum{
  Background = 0,
  Alpinist,
  Enemy,
  Projectile,
  Tile,
}

local SfxEmitter = @record{
  enemy_hit: boolean,
  enemy_laser_shoot: boolean,
  enemy_explosion: boolean,
  alpinist_laser_shoot: boolean,
  alpinist_hit: boolean,
  alpinist_final_hit: boolean,
}

global Game.sfx_emitter: SfxEmitter = {}

global Game.static_settings: record{
  tile_size: integer,
  gravity_acceleration: number,
  map_vel: number,
} <const> = {
  tile_size = 16,
  gravity_acceleration = 10,
  map_vel = 1,
}

require 'entities'

local MapResouces = @record{
  texture: Nene.Texture,
  texture_atlas: Nene.TextureAtlas,
  tilemap: Nene.Tilemap,
  initialized: boolean,
}

function MapResouces:load(path: stringview, nene_state: *Nene.CoreState)
  local ok, err, tex = nene_state:load_texture(path)
  check(ok, err)

  self.texture = tex
  self.texture_atlas = {
    texture = &self.texture,
    unit_width  = Game.static_settings.tile_size,
    unit_height = Game.static_settings.tile_size,
  }
  self.tilemap.atlas = &self.texture_atlas

  self.initialized = true
end

local SpriteResouces = @record{
  texture: Nene.Texture,
  texture_atlas: Nene.TextureAtlas,
  spritesheet: Nene.SpriteSheet,
  initialized: boolean,
}

function SpriteResouces:load(path: stringview, nene_state: *Nene.CoreState)
  local ok, err, tex = nene_state:load_texture(path)
  check(ok, err)

  self.texture = tex
  self.texture_atlas.texture = &self.texture
  self.spritesheet.atlas = &self.texture_atlas

  self.initialized = true
end

global Game.State = @record{
  window_size: Nene.Math.Vec2,
  screen_size: Nene.Math.Vec2,
  nene_state: Nene.CoreState,
  systems: record{
    -- game specific processing systems
    alpinist_controller: GM_Sys.AlpinistController,
    flying_disc_controller: GM_Sys.FlyingDiscController,
    map_controller: GM_Sys.MapController,

    -- game general processing systems
    gravity_applier: RQ_Sys.GravityApplier,
    velocity_applier: RQ_Sys.VelocityApplier,
    position_hierarchy: RQ_Sys.PositionHierarchy,
    intersectable_update: RQ_Sys.IntersectableUpdate,
    intersections_detector: RQ_Sys.IntersectionsDetector,
    follower_system: RQ_Sys.FollowerSystem,
    camera_holder_system: RQ_Sys.CameraHolderSystem,
    sprite_animation: RQ_Sys.SpriteAnimation,

    -- game general painting systems
    shape_painter: RQ_Sys.ShapePainter,
    sprite_painter: RQ_Sys.SpritePainter,
    tilemap_painter: RQ_Sys.TilemapPainter,

    -- debug painting systems
    intersectable_painter: RQ_Sys.IntersectablePainter,
    intersections_painter: RQ_Sys.IntersectionsPainter,
  },
  resources: record{
    alpinist: SpriteResouces,
    flying_disc: SpriteResouces,
    projectile: SpriteResouces,
    map: MapResouces,
    scene_background: Nene.Texture,
    audio: record{
      music: Nene.Music,
      enemy_hit: Nene.Sound,
      enemy_laser_shoot: Nene.Sound,
      enemy_explosion: Nene.Sound,
      alpinist_laser_shoot: Nene.Sound,
      alpinist_hit: Nene.Sound,
      alpinist_final_hit: Nene.Sound,
      initialized: boolean
    }
  },
}
local State = Game.State

function SfxEmitter:play_sounds(game: *Game.State)
  ## for i, field in ipairs(SfxEmitter.value.fields) do
    if self.#|field.name|# then
      game.resources.audio.#|field.name|#:play()
    end
  ## end

  $self = {}
end

local function load_sound(state: *State, path: string): Nene.Sound
  local ok, err, sound = state.nene_state:load_sound(path)
  check(ok, err)
  return sound
end

local function load_music(state: *State, path: string): Nene.Music
  local ok, err, sound = state.nene_state:load_music(path)
  check(ok, err)
  return sound
end

function State.new(title: string, win_width: integer, win_height: integer)
  local screen_w: integer, screen_h: integer = win_width // 2, win_height // 2

  local ok, err, nene_state = Nene.init(title, win_width, win_height,
                                        'resources/monogram_extended.ttf', 16,
                                        screen_w, screen_h)
  check(ok, err)
  SDL_SetRenderDrawBlendMode(nene_state.renderer, SDL_BLENDMODE_BLEND)

  local result: State = {
    window_size = {win_width, win_height},
    screen_size = {screen_w, screen_h},
    =nene_state,
  }

  return result
end

function State:init()
  -- load resources
  do
    -- scene texture
    do
      local ok, err, scene_background = self.nene_state:load_texture'resources/arts/characters/Scene.png'
      check(ok, err)
      self.resources.scene_background = scene_background
    end

    -- audio
    do
      self.resources.audio.music = load_music(self, 'resources/audio/the_great_grog.ogg')
      ## for i, field in ipairs(SfxEmitter.value.fields) do
        self.resources.audio.#|field.name|# = load_sound(self, #['resources/audio/'.. field.name ..'.ogg']#)
      ## end
      self.resources.audio.initialized = true
    end

    -- alpinist
    self.resources.alpinist:load('resources/arts/characters/Personagem.png', self.nene_state)
    self.resources.alpinist.texture_atlas.unit_width = 38
    self.resources.alpinist.texture_atlas.unit_height = 37

    self.resources.alpinist.spritesheet.animations = {
      {name = 'climbing'     , fps = 6.7, from = 4, to = 7},
      {name = 'shooting_down', fps = 1.0, from = 0, to = 0},
      {name = 'shooting_left', fps = 1.0, from = 1, to = 1},
      {name = 'shooting_up'  , fps = 1.0, from = 2, to = 2},
    }

    -- map
    self.resources.map:load('resources/arts/tileset/Tileset.png', self.nene_state)
    self.resources.map.tilemap.width  = 3
    self.resources.map.tilemap.height = 19
    self.resources.map.tilemap.map = {
      0, 1, 1,
      0, 1, 1,
      0, 1, 1,
      0, 1, 1,
      0, 1, 1,
      0, 1, 1,
      0, 1, 1,
      0, 1, 1,
      0, 1, 1,
      0, 1, 1,
      0, 1, 1,
      0, 1, 1,
      0, 1, 1,
      0, 1, 1,
      0, 1, 1,
      0, 1, 1,
      0, 1, 1,
      0, 1, 1,
      0, 1, 1,
    }

    -- flying disc
    self.resources.flying_disc:load('resources/arts/characters/Inimigo.png', self.nene_state)
    self.resources.flying_disc.texture_atlas.unit_width = 20
    self.resources.flying_disc.texture_atlas.unit_height = 25

    -- projectile
    self.resources.projectile:load('resources/arts/characters/Projeteis.png', self.nene_state)
    self.resources.projectile.texture_atlas.unit_width = 10
    self.resources.projectile.texture_atlas.unit_height = 8

    self.resources.projectile.spritesheet.animations = {
      {name = 'proj_alpinist', fps = 18, from = 0, to =  5},
      {name = 'proj_enemy'   , fps = 18, from = 6, to = 11},
    }

    -- dev help: check for non-initialized resources
    ## for i, field in ipairs(State.value.fields.resources.type.fields) do
      check(self.resources.#|field.name|#.initialized, #['the "'..field.name..'" is not initialized']#)
    ## end
  end

  -- init systems
  ## for i, field in ipairs(State.value.fields.systems.type.fields) do
    self.systems.#|field.name|# = (@#[field.type]#).new()
  ## end

  -- init music
  self.nene_state:play_music(self.resources.audio.music, true)
end

function State:systems_update(ent: *Entity)
  -- update systems
  ## for i, field in ipairs(State.value.fields.systems.type.fields) do
    self.systems.#|field.name|#:update(ent)
  ## end
end

function State:create_alpinist(pos: Vec2): GM_Ents.Alpinist
  local pl, pl_ent = GM_Ents.Alpinist.create(pos, self.resources.alpinist.spritesheet)
  self:systems_update(pl_ent)
  return pl
end

function State:create_surf_collider(pos: Vec2, size: Vec2): GM_Ents.SurfaceCollider
  local surf_col, surf_col_ent = GM_Ents.SurfaceCollider.create(pos, size)
  self:systems_update(surf_col_ent)
  return surf_col
end

function State:create_flying_disc(pos: Vec2)
  local fd, fd_ent = GM_Ents.FlyingDisc.create(pos, self.resources.flying_disc.spritesheet)
  self:systems_update(fd_ent)
  return fd
end

function State:create_projectile(pos: Vec2, dir: Vec2, speed: Game.Entities.Projectile.Speed, mask: Game.IntersectableMasks)
  local proj, proj_ent = GM_Ents.Projectile.create(pos,
                                                   dir,
                                                   self.resources.projectile.spritesheet,
                                                   speed * self.nene_state.deltatime,
                                                   mask)
  self:systems_update(proj_ent)
  return proj_ent
end

function State:create_map(pos: Vec2): GM_Ents.Map
  local map, map_ent = GM_Ents.Map.create(pos, self.resources.map.tilemap)
  self:systems_update(map_ent)
  return map
end

function State:terminate()
  self.nene_state:terminate()
end
